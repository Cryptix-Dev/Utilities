apply plugin: 'eclipse'

// NOTICE: javaSourceCompatibility & javaTargetCompatibility need to be created as external variables
// NOTICE: TargetSDK & BuildTools need to be created as external variables

// TASKS:
//      copyAars (runs after eclipse) - prepares support library dependencies
//      copyEclipseClasspath (runs after copyAars) - imports gradle dependecies
//      cleanEclipseGradle (runs after cleanEclipse) - deletes bins, deps, gen, and project.properties
//      genBaseSrcDirs (runs after eclipse) - generates all java, res, gen, and assets folders
//      genSrcDirs - generates all source folders (java, res, assets, rs, resources, aidl)
//      refreshBuild - refreshes project.properties buildtools & target SDK

eclipse.classpath.file {
    withXml {
        def props = new Properties()
        def writer = new FileWriter(file('project.properties'))
        try {
            props.setProperty("target", "android-${TargetSDK}")
            props.setProperty("sdk.buildtools", "${BuildTools}")
            props.store(writer, null)
            writer.flush()
        } finally {
            writer.close()
        }
    
        def node = it.asNode()
        def subLength = projectDir.toString().length() + 1   
        android.sourceSets*.java.srcDirs*.each {
            def path = it.getPath().substring(subLength, it.getPath().length()).replaceAll("\\\\", "/")
            node.appendNode("classpathentry kind=\"src\" path=\"${path}\"")
        }
        android.sourceSets*.res.srcDirs*.each {
            def path = it.getPath().substring(subLength, it.getPath().length()).replaceAll("\\\\", "/")
            node.appendNode("classpathentry kind=\"src\" path=\"${path}\"")
        }
        android.sourceSets*.assets.srcDirs*.each {
            def path = it.getPath().substring(subLength, it.getPath().length()).replaceAll("\\\\", "/")
            node.appendNode("classpathentry kind=\"src\" path=\"${path}\"")
        }
        android.sourceSets*.aidl.srcDirs*.each {
            def path = it.getPath().substring(subLength, it.getPath().length()).replaceAll("\\\\", "/")
            node.appendNode("classpathentry kind=\"src\" path=\"${path}\"")
        }
        android.sourceSets*.resources.srcDirs*.each {
            def path = it.getPath().substring(subLength, it.getPath().length()).replaceAll("\\\\", "/")
            node.appendNode("classpathentry kind=\"src\" path=\"${path}\"")
        }
        android.sourceSets*.renderscript.srcDirs*.each {
            def path = it.getPath().substring(subLength, it.getPath().length()).replaceAll("\\\\", "/")
            node.appendNode("classpathentry kind=\"src\" path=\"${path}\"")
        }
        node.appendNode('classpathentry kind="src" path="gen"')
        
        node.children().removeAll() { c ->
            def path = c.attribute('path')
            path != null && (
                    path.contains('/com.android.support/support-v4')
                    )
        }
    }
    
    beforeMerged { classpath ->
        classpath.entries.removeAll() { c ->
            c.kind == 'src'
        }
    }
}

eclipse.jdt {
    sourceCompatibility = javaSourceCompatibility
    targetCompatibility = javaTargetCompatibility
}

eclipse.project {
    name = "${projectName}-${project.name}"
    natures 'com.android.ide.eclipse.adt.AndroidNature'
    buildCommand 'com.android.ide.eclipse.adt.ResourceManagerBuilder'
    buildCommand 'com.android.ide.eclipse.adt.PreCompilerBuilder'
    buildCommand 'com.android.ide.eclipse.adt.ApkBuilder'
}

task copyAars << {
    configurations.compile.filter { it.name.endsWith 'aar' }.each { File file -> copyAndRenameAar(file) }
    def aarsFolder = new File("${projectDir}/deps/aars/exploded")
    if (aarsFolder.exists()) {
        Properties props = new Properties()
        def propsFile = new File("${projectDir}/project.properties")
        props.load(propsFile.newDataInputStream())
        
        int count = 1
        aarsFolder.eachDir() { dir ->
            def parts = dir.getPath().split("\\\\")
            props.setProperty(
            "android.library.reference.${count}", "deps/aars/exploded/${parts[parts.size()-1]}")
            count++
        }
        props.store(propsFile.newWriter(), null)
    }
}

void copyAndRenameAar(File file) {
    println 'Added aar ' + file
    def baseFilename = file.name.lastIndexOf('.').with { it != -1 ? file.name[0..<it] : file.name }

    // directory excluding the classes.jar
    copy {
        from zipTree(file)
        exclude 'classes.jar'
        into "deps/aars/exploded/" + baseFilename
    }

    // Copies the classes.jar into the libs directory of the expoded AAR.
    // In Eclipse you can then import this exploded aar as an Android project
    // and then reference not only the classes but also the android resources
    copy {
        from zipTree(file)
        include 'classes.jar'
        into "deps/aars/exploded/" + baseFilename + "/libs"
        rename { String fileName -> fileName.replace('classes.jar', baseFilename + '.jar') }
    }
}

task copyEclipseClasspath << {
    def classpath = new XmlParser().parse(file(".classpath"))
    def libs = classpath.grep { it.'@gradle-dependency' == "true" }
    libs.each { classpath.remove(it) }

    configurations.compile.filter { it.name.endsWith 'jar' }
    .collect { file ->
        new Node(null, "classpathentry", [
            "path": file.toString(),
            "kind": "lib",
            "exported": "true",
            "gradle-dependency": "true"
        ])
    }
    .each { classpath.append(it) }

    file(".classpath").withWriter { writer ->
        writer << new groovy.xml.StreamingMarkupBuilder().bind { mkp.xmlDeclaration() }
        def printer = new XmlNodePrinter(new PrintWriter(writer))
        printer.print(classpath)
    }
}

task refreshBuild << {
    Properties props = new Properties()
    def propsFile = new File("${projectDir}/project.properties")
    props.load(propsFile.newDataInputStream())
    props.setProperty("target", "android-${TargetSDK}")
    props.setProperty("sdk.buildtools", "${BuildTools}")
    props.store(propsFile.newWriter(), null)
}

task cleanEclipseGradle << {
    def binsDir = new File("${projectDir}/bin")
    def depsDir = new File("${projectDir}/deps")
    def genDir  = new File("${projectDir}/gen")
    def projectProps = new File("${projectDir}/project.properties")
    binsDir.deleteDir()
    depsDir.deleteDir()
    genDir.deleteDir()
    projectProps.delete()
}

task genSrcDirs << {
    android.sourceSets*.java.srcDirs*.each { it.mkdirs() }
    android.sourceSets*.resources.srcDirs*.each { it.mkdirs() }
    android.sourceSets*.renderscript.srcDirs*.each { it.mkdirs() }
    android.sourceSets*.aidl.srcDirs*.each { it.mkdirs() }
    android.sourceSets*.res.srcDirs*.each { it.mkdirs() }
    android.sourceSets*.assets.srcDirs*.each { it.mkdirs() }
    new File("${projectDir}/gen").mkdirs()
}

task genBaseSrcDirs << {
    android.sourceSets*.java.srcDirs*.each { it.mkdirs() }
    android.sourceSets*.assets.srcDirs*.each { it.mkdirs() }
    android.sourceSets*.res.srcDirs*.each { it.mkdirs() }
    new File("${projectDir}/gen").mkdirs()
}
tasks.eclipse.finalizedBy(genBaseSrcDirs)

tasks.eclipse.finalizedBy(copyAars)
copyAars.finalizedBy(copyEclipseClasspath)
copyEclipseClasspath.mustRunAfter copyAars

cleanEclipse.finalizedBy(cleanEclipseGradle)